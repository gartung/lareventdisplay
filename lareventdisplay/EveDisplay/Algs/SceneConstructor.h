////////////////////////////////////////////////////////////////////////
// Class:       SceneConstructor
// Module Type: analyzer
// File:        SceneConstructor.h
// Brief:       Module template to construct a TEveScene of related data product visulizations
//
// Generated at Tue May 17 13:33:55 2016 by Andrew Olivier using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

//Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"

//LArSoft includes
#include "lareventdisplay/EveDisplay/GUI/EveDisplay.h"
#include "lareventdisplay/EveDisplay/Algs/AlgHolder.h"

//ROOT includes
#include "TEveScene.h"
#include "TEveTrack.h"
#include "TEvePathMark.h"
#include "TVector3.h"
#include "TEveVector.h"
#include "TGLViewer.h"
#include "TEveProjections.h"
#include "TEveProjectionAxes.h"

//c++ includes
#include <memory>

namespace eved {
  template <class ...ALGS>
  class SceneConstructor;
}

//The following flow of function calls seems like it could ensure scene creation in time for viewer creation:
//*Scenes are REQURESTED from TEveManager at module construction
//*Windows are created and given to TEveManager in beginJob
//  *Viewers are requested from TEveManager as needed by windows
//  *Scenes are added to viewers.  We will throw if we don't find a scene we need.  It is up to the user-controllable ART configuration of exception handling 
//   to decide whether to proceed without the needed scene.
//*Scenes are reset and filled in analyze()

//Template Parameters
//ALGS: A list of algorithms that construct TEveScene objects
//An ALG must have the following methods: 
//*ALG::ALG()
//*void ALG::reconfigure(const fhicl::ParameterSet& p)
//*void ALG::makeEvent(const art::Event& evt) 
//*TEveScene* ALG::makeGlobal() 
//*void ALG::initialize()

template <class ...ALGS>

class eved::SceneConstructor : public art::EDAnalyzer, virtual SingleAlgHolder<ALGS>... {
public:
  explicit SceneConstructor(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SceneConstructor(SceneConstructor const &) = delete;
  SceneConstructor(SceneConstructor &&) = delete;
  SceneConstructor & operator = (SceneConstructor const &) = delete;
  SceneConstructor & operator = (SceneConstructor &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

};

template <class ...ALGS>
eved::SceneConstructor<ALGS...>::SceneConstructor(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
  //SingleAlgHolder<ALGS>()...
 // More initializers here.
{
  reconfigure(p);
  // Implementation of optional member function here.
  int null[] = { (SingleAlgHolder<ALGS>::get()->makeGlobal(), 0)... };
  (void)null;
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  mf::LogWarning("SceneConstructor") << "Making scenes in SceneConstructor.\n";
  int null[] = {(SingleAlgHolder<ALGS>::get()->makeEvent(e), 0)...};
  (void)null; //convince the compiler that null is used without generating any code
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::beginJob()
{
  // Implementation of optional member function here.
  int null[] = {0, (SingleAlgHolder<ALGS>::get()->initialize(), 0)..., 0};
  (void)null; //convince the compiler that null is used without generating any code
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::beginSubRun(art::SubRun const & sr)
{
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::endJob()
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  int null[] = {0, (SingleAlgHolder<ALGS>::get()->reconfigure(p), 0)..., 0};
  (void)null; //convince the compiler that null is used without generating any code
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

template <class ...ALGS>
void eved::SceneConstructor<ALGS...>::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

//Call this in a separate file to make your viewer using this template: 
//#typedef eved::SceneConstructor<ALG1, ALG2, ALG3> YourViewerName
//DEFINE_ART_MODULE(YourViewerName)
