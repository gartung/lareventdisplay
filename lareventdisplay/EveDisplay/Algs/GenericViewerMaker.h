////////////////////////////////////////////////////////////////////////
// Class:       GenericViewerMaker
// Module Type: analyzer
// File:        GenericViewerMaker_module.cc
// Brief:       Module template to make a generic viewer for the Eve-based event display 
//
// Generated at Tue May 17 13:33:55 2016 by Andrew Olivier using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

//Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Common/PtrVector.h"

//LArSoft includes
#include "lareventdisplay/EveDisplay/GUI/EveDisplay.h"
#include "lareventdisplay/EveDisplay/Algs/AlgHolder.h"

//ROOT includes
#include "TEveViewer.h"
#include "TEveScene.h"
#include "TEveTrack.h"
#include "TEvePathMark.h"
#include "TVector3.h"
#include "TEveVector.h"
#include "TGLViewer.h"
#include "TEveProjections.h"
#include "TEveProjectionAxes.h"

//c++ includes
#include <memory>

namespace eved {
  template <std::string& NAME, class ...ALGS>
  class GenericViewerMaker;
}

//Template Parameters
//ALGS: A list of algorithms that construct TEveScene objects
//An ALG must have the following methods: 
//*ALG::ALG()
//*void ALG::reconfigure(const fhicl::ParameterSet& p)
//*void ALG::makeEvent(const art::Event& evt) 
//*TEveScene* ALG::makeGlobal() 
//*void ALG::initialize()

//NAME: the name of this TEveViewer in the event display

template <std::string& NAME, class ...ALGS>

class eved::GenericViewerMaker : public art::EDAnalyzer, virtual SingleAlgHolder<ALGS>... {
public:
  explicit GenericViewerMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  GenericViewerMaker(GenericViewerMaker const &) = delete;
  GenericViewerMaker(GenericViewerMaker &&) = delete;
  GenericViewerMaker & operator = (GenericViewerMaker const &) = delete;
  GenericViewerMaker & operator = (GenericViewerMaker &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  //AlgHolder<ALGS...> fAlgHolder;
  TEveViewer* fViewer;
  //TEveProjectionAxes*    fAxes;

};

template <std::string &NAME, class ...ALGS>
eved::GenericViewerMaker<NAME, ALGS...>::GenericViewerMaker(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p), fViewer(0)
  //SingleAlgHolder<ALGS>()...
 // More initializers here.
{
  fViewer = art::ServiceHandle<eved::EveDisplay>()->getEve()->SpawnNewViewer(NAME.c_str());
  reconfigure(p);
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  mf::LogWarning("GenericViewerMaker") << "Making scenes in GenericViewerMaker.\n";
  int null[] = {(SingleAlgHolder<ALGS>::get()->makeEvent(e), 0)...};
  (void)null; //convince the compiler that null is used without generating any code
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::beginJob()
{
  // Implementation of optional member function here.
  int null[] = {0, (SingleAlgHolder<ALGS>::get()->initialize(), 0)..., 0};
  (void)null; //convince the compiler that null is used without generating any code
 
  auto glview = fViewer->GetGLViewer(); //Temporary set up of GLViewer.  This should be fcl-controlled in the future...
  glview->UseLightColorSet();
  glview->SetGuideState(TGLUtil::kAxesEdge, kTRUE, kFALSE, 0);
  glview->PreferLocalFrame();
  glview->ResetCameras();
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
  int null[] = { (fViewer->AddScene(SingleAlgHolder<ALGS>::get()->makeGlobal()), 0)... };
  (void)null;

  //fViewer->AddElement(fAxes); //Need to find a way to get these into each view
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::endJob()
{
  // Implementation of optional member function here.
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

template <std::string& NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  int null[] = {0, (SingleAlgHolder<ALGS>::get()->reconfigure(p), 0)..., 0};
  (void)null; //convince the compiler that null is used without generating any code
}

template <std::string& NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

template <std::string& NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

template <std::string &NAME, class ...ALGS>
void eved::GenericViewerMaker<NAME, ALGS...>::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

//Call this in a separate file to make your viewer using this template: 
//#typedef eved::GenericViewerMaker<ALG1, ALG2, ALG3> YourViewerName
//DEFINE_ART_MODULE(YourViewerName)
