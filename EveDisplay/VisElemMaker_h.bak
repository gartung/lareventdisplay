////////////////////////////////////////////////////////////////////////
// Class:       VisElemMaker
// Module Type: producer
// File:        VisElemMaker_module.cc
//
// Generated at Sun Apr 24 13:39:49 2016 by Andrew Olivier using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

//ART includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Common/PtrVector.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//c++ includes
#include <memory>

//LArSoft includes
#include "Utilities/AssociationUtil.h"

//ROOT includes

#ifndef EVED_VISELEMMAKER_MODULE_CC
#define EVED_VISELEMMAKER_MODULE_CC

/*namespace eved {
  template<class ALG, class PROD>
  class VisElemMaker<ALG, PROD>;
}*/

namespace eved {
template<class ALG, class PROD, class VIS>

//First template parameter: algorithm
//Algorithms are classes that:
//*can be constructed from a fhicl::ParameterSet
//*map LArSoft data products to Eve visualization objects
//
//Algorithms must have the following functions:
//* void Initialize() //perform beginning of job initialization (like getting needed services)
//* VIS MakeVis(const PROD &prod)
//make and return visualization elements
//
//Fill in other algorithm requirements here!

//Second template parameter: data product
//A LArSoft data product that ALG maps to an Eve visualization class

//Third template parameter: visualization object
//An Eve visualization object 

class VisElemMaker : public art::EDProducer {
public:
  explicit VisElemMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  VisElemMaker(VisElemMaker const &) = delete;
  VisElemMaker(VisElemMaker &&) = delete;
  VisElemMaker & operator = (VisElemMaker const &) = delete;
  VisElemMaker & operator = (VisElemMaker &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  //void beginRun(art::Run & r) override;
  //void beginSubRun(art::SubRun & sr) override;
  //void endJob() override;
  //void endRun(art::Run & r) override;
  //void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  //void respondToCloseInputFile(art::FileBlock const & fb) override;
  //void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  //void respondToOpenInputFile(art::FileBlock const & fb) override;
  //void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  std::unique_ptr<ALG> fAlg; //Your algorithm for making TEveElements from PRODs
  std::string fDataLabel; //The label to be used to get data products
};

template<class ALG, class PROD, class VIS>
VisElemMaker<ALG, PROD, VIS>::VisElemMaker(fhicl::ParameterSet const & p): fAlg() //will reset() the unique_ptr in Reconfigure()
// Initialize member data here.
{ 
  this->reconfigure(p);

  // Call appropriate produces<>() functions here.
  produces<std::vector<VIS>>();
  produces<art::Assns<PROD, VIS>>();
}

template<class ALG, class PROD, class VIS>
void VisElemMaker<ALG, PROD, VIS>::produce(art::Event & e)
{
  // Implementation of required member function here.
  // Handle ART "nastiness" for the user here
  // One could also make a GetDataProducts function to enforce criteria on data products somewhere around here
  std::unique_ptr<art::Assns<PROD, VIS>> Assns(new art::Assns<PROD, VIS>());
  std::unique_ptr<std::vector<VIS>> VisCol(new std::vector<VIS>()); 

  art::Handle<std::vector<PROD>> prodHand;
  e.getByLabel(fDataLabel, prodHand);

  std::vector<art::Ptr<PROD>> prodVec;
  fill_ptr_vector(prodVec, prodHand);

  for(const auto& prod: prodVec)
  {
    VisCol->push_back(fAlg->MakeVis(prod)); 
    size_t VisPos = VisCol->size()-1; //position of object we want to associate
    util::CreateAssn(*this, e, *VisCol, prod, *Assns, VisPos);
  }

  e.put(std::move(VisCol));
  e.put(std::move(Assns));
}

template<class ALG, class PROD, class VIS>
void VisElemMaker<ALG, PROD, VIS>::beginJob()
{
  // Implementation of optional member function here.
  fAlg->Initialize();
}

/*void VisElemMaker::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
  // fAlg->InitRun(); //Do we want this?  
}*/

/*void VisElemMaker::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}*/

/*void VisElemMaker::endJob()
{
  // Implementation of optional member function here.
}*/

/*void VisElemMaker::endRun(art::Run & r)
{
  // Implementation of optional member function here.
}*/

/*void VisElemMaker::endSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}*/

template<class ALG, class PROD, class VIS>
void VisElemMaker<ALG, PROD, VIS>::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fAlg.reset(new ALG(p));

  fDataLabel = p.get<std::string>("DataLabel");
}

/*void VisElemMaker::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void VisElemMaker::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void VisElemMaker::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void VisElemMaker::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}*/

//Specialization of VisElementMaker for std::vector<PROD>

template <class ALG, class PROD, class VIS>
//See template explanation above.  Only difference is std::vector<PROD> replaces PROD, so we make many-to-one associations

class VisElemMaker<ALG, std::vector<PROD>, VIS> : public art::EDProducer {
public:
  explicit VisElemMaker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  VisElemMaker(VisElemMaker const &) = delete;
  VisElemMaker(VisElemMaker &&) = delete;
  VisElemMaker & operator = (VisElemMaker const &) = delete;
  VisElemMaker & operator = (VisElemMaker &&) = delete;
  
  // Required functions.
  void produce(art::Event & e) override;
  
  // Selected optional functions.
  void beginJob() override;
  //void beginRun(art::Run & r) override;
  //void beginSubRun(art::SubRun & sr) override;
  //void endJob() override;
  //void endRun(art::Run & r) override;
  //void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  //void respondToCloseInputFile(art::FileBlock const & fb) override;
  //void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  //void respondToOpenInputFile(art::FileBlock const & fb) override;
  //void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  
private:
  // Declare member data here.
  std::unique_ptr<ALG> fAlg; //Your algorithm for making TEveElements from PRODs
  std::string fDataLabel; //The label to be used to get data products
};

template<class ALG, class PROD, class VIS>
void VisElemMaker<ALG, std::vector<PROD>, VIS>::produce(art::Event & e)
{
  // Implementation of required member function here.
  // Handle ART "nastiness" for the user here
  // One could also make a GetDataProducts function to enforce criteria on data products somewhere around here

  std::unique_ptr<art::Assns<PROD, VIS>> Assns(new art::Assns<PROD, VIS>());
  std::unique_ptr<std::vector<VIS>> VisCol(new std::vector<VIS>());

  art::Handle<std::vector<PROD>> prodHand;
  e.getByLabel(fDataLabel, prodHand);

  std::vector<art::Ptr<PROD>> prodVec;
  fill_ptr_vector(prodVec, prodHand);

  VisCol->push_back(fAlg->MakeVis(prodVec));
  size_t VisPos = VisCol->size()-1; //position of object we want to associate
  util::CreateAssn(*this, e, *VisCol, prodVec, *Assns, VisPos);

  e.put(std::move(VisCol));
  e.put(std::move(Assns));
}

template<class ALG, class PROD, class VIS>
VisElemMaker<ALG, std::vector<PROD>, VIS>::VisElemMaker(fhicl::ParameterSet const & p): fAlg()
{
  this->reconfigure(p);

   // Call appropriate produces<>() functions here.
   produces<std::vector<VIS>>();
   produces<art::Assns<std::vector<PROD>, VIS>>();
}

template<class ALG, class PROD, class VIS>
void VisElemMaker<ALG, std::vector<PROD>, VIS>::beginJob()
{
  // Implementation of optional member function here.
  fAlg->Initialize();
}

template<class ALG, class PROD, class VIS>
void VisElemMaker<ALG, std::vector<PROD>, VIS>::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fAlg.reset(new ALG(p));

  fDataLabel = p.get<std::string>("DataLabel");
}

//template<class ALG, class PROD>
//DEFINE_ART_MODULE(eved::VisElemMaker<ALG, PROD>) //Add these two lines, filling in the templates, when you declare an alg you want to use

} //end namespace eved

#endif

